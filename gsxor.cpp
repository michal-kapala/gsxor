#include "gsxor.hpp"

static void print_buf(unsigned char* buf, unsigned int size) {
    for (size_t i = 0; i < size; i++)
        printf("%02X ", *(buf + i));
    printf("\n");
}

void GSXor_Encrypt(unsigned char* input, unsigned int size) {
    for (size_t i = 0; i < size; i++)
        input[i] ^= (unsigned char)i - 119;

    unsigned int size_root = (unsigned int)sqrt(size);
    if (pow(size_root, 2) < size)
        ++size_root;

    unsigned int new_size = 2 * size_root * size_root;
    signed short* buf = (signed __int16*)malloc(new_size);
    memset(buf, -1, new_size);
    int A = 0;
    int B = 0;
    for (size_t i = 0; i < size; i++) {
        if (A < size_root) {
            if (B < 0) {
                B = A;
                A = 0;
            }
        }
        else {
            A = B + 2;
            B = size_root - 1;
        }
        buf[A++ + size_root * B--] = input[i];
    }

    int idx = 0;
    for (size_t j = 0; j < size_root; j++) {
        for (size_t k = 0; k < size_root; k++) {
            if (buf[k + size_root * j] != -1)
                input[idx++] = buf[k + size_root * j];
        }
    }
    free(buf);
}

void GSXor_Decrypt(unsigned char* input, unsigned int size) {
    double root = sqrt(size);
    unsigned int size_root = (unsigned long long)root;
    if ((double)size_root < root)
        ++size_root;
    unsigned int new_size = size_root * size_root;
    unsigned char* buf = (unsigned char*)malloc(new_size);
    memset(buf, 0, new_size);

    int A = 0;
    int B = 0;
    unsigned char* buf_cpy = buf;
    if (size > 0) {
        unsigned int size_cpy = size;
        do {
            if (B < size_root) {
                if (A < 0) {
                    A = B;
                    B = 0;
                }
            }
            else {
                B = A + 2;
                A = size_root - 1;
            }
            unsigned int idx = B++ + size_root * A--;
            --size_cpy;
            *(buf + idx) = (unsigned char)1;
        } while (size_cpy);
    }

    int C = 0;
    int D = 0;
    if (size > 0) {
        int count = 0;
        do {
            if (C >= size_root) {
                count += size_root;
                C = 0;
            }
            unsigned char* ptr = &buf_cpy[count + C];
            if (*ptr)
                *ptr = input[D++];
            ++C;
        } while (D < size);
    }

    int E = 0;
    int F = 0;
    for (size_t idx = 0; idx < size; ++idx) {
        if (F < size_root) {
            if (E < 0) {
                E = F;
                F = 0;
            }
        }
        else {
            F = E + 2;
            E = size_root - 1;
        }
        input[idx] = buf_cpy[F++ + size_root * E--];
    }

    for (size_t i = 0; i < size; ++i)
        input[i] ^= (unsigned char)i - 119;
}

static void test(unsigned char* input, const unsigned int size, const std::string test_name) {
    unsigned char* ptr = input;
    printf("%s test\nData:\n", test_name.c_str());
    print_buf(input, size);
    GSXor_Encrypt(ptr, size);
    printf("Encrypted:\n");
    print_buf(input, size);
    GSXor_Decrypt(ptr, size);
    printf("Decrypted:\n");
    print_buf(input, size);
    printf("\n");
}

int main()
{
    unsigned char plaintext[] = {
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',
        'A', 'S', 'D', 'A', 'S', 'D', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
    };
    // 1st key exchange packet
    unsigned char packet1[] = {
        0x73, 0x31, 0x00, 0x5B, 0x73, 0x31, 0x00, 0x73, 0x32, 0x36, 0x30, 0x00, 0x62, 0x00, 0x00, 0x01,
        0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0xE9, 0x3D, 0x55, 0x27, 0x4B, 0xE0, 0xAA, 0xCE, 0x4E, 0xFF,
        0x77, 0xD0, 0x29, 0x66, 0x1C, 0xF7, 0x45, 0xC0, 0xF4, 0x93, 0x4C, 0xCB, 0xF0, 0xD0, 0xAF, 0x7C,
        0x30, 0x4F, 0x71, 0x69, 0x8F, 0x85, 0x16, 0xF0, 0x55, 0x49, 0x21, 0x93, 0x19, 0x62, 0xF6, 0xF2,
        0x04, 0x57, 0x2C, 0xDD, 0x23, 0xC6, 0xBA, 0x6C, 0xB5, 0xDD, 0x20, 0xA7, 0xD3, 0x60, 0x96, 0x75,
        0x4B, 0xD7, 0xE8, 0x9A, 0x5B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x03, 0x5D
    };
    
    
    // 2nd key exchange packet
    unsigned char packet2[] = {
        0x73, 0x32, 0x00, 0x5B, 0x73, 0x31, 0x00, 0x73, 0x36, 0x34, 0x00, 0x62, 0x00, 0x00, 0x00, 0x40,
        0xBE, 0x29, 0x0C, 0x40, 0x48, 0xE3, 0x6D, 0x18, 0x98, 0x39, 0x92, 0x75, 0x83, 0xC3, 0x77, 0x28,
        0x08, 0x83, 0xCA, 0xE3, 0xEF, 0x34, 0x40, 0xFC, 0x0B, 0x3A, 0x11, 0x17, 0x24, 0xA3, 0xC7, 0x40,
        0x42, 0xC6, 0xD8, 0x29, 0x6B, 0xFA, 0x72, 0xB3, 0x2B, 0x49, 0xD6, 0x9E, 0xB3, 0xCC, 0xC4, 0x50,
        0xAB, 0x2B, 0x2D, 0x8D, 0xFB, 0x76, 0xD8, 0x26, 0x8C, 0x2F, 0x2A, 0xE0, 0x81, 0x0A, 0x58, 0x1A,
        0x5D
    };
    
    test(plaintext, sizeof(plaintext), "Plaintext");
    test(packet1, sizeof(packet1), "Packet 1");
    test(packet2, sizeof(packet2), "Packet 2");
    return 0;
}
